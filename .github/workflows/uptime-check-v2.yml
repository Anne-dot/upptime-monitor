name: Uptime Check v2

# ============================================
# Single Source of Truth: sites.json
# Retry: 3 katset enne alerti
# ============================================

on:
  schedule:
    - cron: "*/30 * * * *"
  workflow_dispatch:

env:
  TEST_MODE: "true"
  TECH_EMAIL: "ruusmann@gmail.com"

jobs:
  # ============================================
  # JOB 1: Kontrolli koiki saite
  # ============================================
  check:
    runs-on: ubuntu-latest
    outputs:
      errors: ${{ steps.check.outputs.errors }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Kontrolli saite
        id: check
        run: |
          echo "========================================"
          echo "Uptime Check v2 - $(date)"
          echo "========================================"

          # Error messages - single source of truth for all error texts
          ERR_NO_CONFIG="CRITICAL: sites.json not found!"
          ERR_INVALID_JSON="CRITICAL: sites.json is not valid JSON!"
          ERR_EMPTY_CONFIG="WARNING: sites.json is empty, nothing to check"
          ERR_MISSING_URL="WARNING: URL missing, skipping site"
          ERR_DNS="DNS error - host not found"
          ERR_CONNECTION="Connection failed - server down?"
          ERR_PHP="PHP error on page"

          # Fail fast if config is broken - no point continuing with bad data
          if [ ! -f sites.json ]; then
            echo "$ERR_NO_CONFIG"
            exit 1
          fi
          if ! jq empty sites.json 2>/dev/null; then
            echo "$ERR_INVALID_JSON"
            exit 1
          fi

          ERRORS="[]"

          SITE_COUNT=$(jq length sites.json)

          if [ "$SITE_COUNT" -eq 0 ]; then
            echo "$ERR_EMPTY_CONFIG"
            echo "errors=[]" >> $GITHUB_OUTPUT
            exit 0
          fi

          for i in $(seq 0 $((SITE_COUNT - 1))); do
            name=$(jq -r ".[$i].name" sites.json)
            url=$(jq -r ".[$i].url" sites.json)
            is_php=$(jq -r ".[$i].is_php" sites.json)
            check_ssl=$(jq -r ".[$i].ssl" sites.json)
            emails=$(jq -r ".[$i].emails" sites.json)

            echo ""
            echo "--- $name ---"

            # Skip sites with missing or invalid URL
            if [ "$url" = "null" ] || [ -z "$url" ]; then
              echo "$ERR_MISSING_URL"
              continue
            fi

            reason=""

            # Retry 3 times with increasing timeout (30s, 60s, 90s)
            for attempt in 1 2 3; do
              reason=""

              # Increase timeout with each attempt
              case $attempt in
                1) timeout=30 ;;
                2) timeout=60 ;;
                3) timeout=90 ;;
              esac

              # Single curl request: content + HTTP status + response time
              set +e
              full_response=$(curl -sL -w "\n%{http_code}\n%{time_total}" --max-time $timeout "$url" 2>&1)
              curl_exit=$?
              set -e

              # Parse response: content, HTTP status, response time
              time_total=$(echo "$full_response" | tail -1)
              status=$(echo "$full_response" | tail -2 | head -1)
              response=$(echo "$full_response" | sed -n '1,/^[0-9]\{3\}$/{ /^[0-9]\{3\}$/d; p; }')

              # Different curl exit codes mean different problems
              if [ $curl_exit -eq 28 ]; then
                reason="Timeout (>${timeout}s) - site slow"
              elif [ $curl_exit -eq 6 ]; then
                reason="$ERR_DNS"
              elif [ $curl_exit -eq 7 ]; then
                reason="$ERR_CONNECTION"
              elif [ $curl_exit -ne 0 ]; then
                reason="Curl error (exit $curl_exit)"
              elif [ "$status" != "200" ]; then
                reason="HTTP error: $status"
              else
                echo "OK: HTTP $status (${time_total}s)"

                # Check for PHP errors in response body
                if [ "$is_php" = "true" ]; then
                  if echo "$response" | grep -qE "(<b>Fatal error</b>|<b>Parse error</b>|<b>Warning</b>)"; then
                    reason="$ERR_PHP"
                  fi
                fi

                # Check SSL certificate expiry
                if [ -z "$reason" ] && [ "$check_ssl" = "true" ]; then
                  host=$(echo "$url" | sed 's|https://||' | sed 's|/.*||')
                  set +e
                  expiry=$(echo | openssl s_client -connect "$host:443" -servername "$host" 2>/dev/null | openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2)
                  set -e
                  if [ -n "$expiry" ]; then
                    expiry_epoch=$(date -d "$expiry" +%s 2>/dev/null || echo "0")
                    now_epoch=$(date +%s)
                    if [ "$expiry_epoch" != "0" ]; then
                      days_left=$(( (expiry_epoch - now_epoch) / 86400 ))
                      if [ $days_left -le 7 ]; then
                        reason="SSL certificate expires in $days_left days"
                      fi
                    fi
                  fi
                fi
              fi

              # Success - no need to retry
              if [ -z "$reason" ]; then
                echo "OK (attempt $attempt)"
                break
              fi

              # Failed but not last attempt - wait and retry
              if [ $attempt -lt 3 ]; then
                echo "Attempt $attempt failed: $reason - waiting 10s..."
                sleep 10
              fi
            done

            # Final result after all retries
            if [ -n "$reason" ]; then
              echo "FAILED (after 3 attempts): $reason"
              # Escape quotes in reason to avoid breaking JSON
              reason_escaped=$(echo "$reason" | sed 's/"/\\"/g')
              ERRORS=$(echo "$ERRORS" | jq -c ". + [{\"name\": \"$name\", \"url\": \"$url\", \"reason\": \"$reason_escaped\", \"emails\": \"$emails\"}]")
            else
              echo "ALL OK"
            fi
          done

          echo ""
          echo "========================================"
          echo "Errors: $ERRORS"
          echo "========================================"

          echo "errors=$ERRORS" >> $GITHUB_OUTPUT

  # Send alert emails - one per failed site
  notify:
    needs: check
    if: needs.check.outputs.errors != '[]'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false  # One failed email should not stop others
      matrix:
        error: ${{ fromJSON(needs.check.outputs.errors) }}
    steps:
      - name: Send alert - ${{ matrix.error.name }}
        continue-on-error: true  # Log failure but don't fail the job
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 465
          username: ${{ secrets.MAIL_USERNAME }}
          password: ${{ secrets.MAIL_PASSWORD }}
          subject: "⚠️ ${{ matrix.error.name }} probleem"
          to: ${{ env.TEST_MODE == 'true' && env.TECH_EMAIL || matrix.error.emails }}
          from: Veebilehtede seire
          body: |
            ${{ matrix.error.name }} ei toota!

            Pohjus: ${{ matrix.error.reason }}

            Kontrolli lehte: ${{ matrix.error.url }}
